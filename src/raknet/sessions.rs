use std::net::SocketAddr;
use std::sync::Arc;
use std::sync::atomic::{AtomicU32, Ordering};
use std::time::{Duration, Instant};

use bytes::{Buf, BytesMut};
use dashmap::DashMap;
use parking_lot::RwLock;
use tokio_util::sync::CancellationToken;

use crate::error::VexResult;
use crate::raknet::{CompoundCollector, FrameBatch, OrderChannel, SendPriority, SendQueue};
use crate::raknet::packet::RawPacket;
use crate::raknet::packets::{Ack, AckRecord, Decodable, Encodable, Nack, RaknetDisconnect};
use crate::util::AsyncDeque;
use crate::vex_error;

/// Tick interval of the internal session ticker.
const INTERNAL_TICK_INTERVAL: Duration = Duration::from_millis(1000 / 20);
/// Tick interval for session packet processing.
const TICK_INTERVAL: Duration = Duration::from_millis(1000 / 20);
/// Inactivity timeout.
///
/// Any sessions that do not respond within this specified timeout will be disconnect from the server.
/// Timeouts can happen if a client's game crashed for example.
/// They will stop responding to the server, but will not explicitly send a disconnect request.
/// Hence, they have to be disconnected manually after the timeout passes.
const SESSION_TIMEOUT: Duration = Duration::from_secs(5);

const ORDER_CHANNEL_COUNT: usize = 5;

/// Sessions directly correspond to clients connected to the server.
///
/// Anything that has to do with specific clients must be communicated with their associated sessions.
/// The server does not interact with clients directly, everything is done through these sessions.
///
#[derive(Debug)]
pub struct Session {
    /// IP address of this session.
    address: SocketAddr,
    /// Client-provided GUID.
    /// These IDs are randomly generated by Minecraft on each startup and are unreliable.
    /// They should not be used as unique identifiers, use the XUID instead.
    guid: i64,
    /// Timestamp of when the last packet was received from this client.
    last_update: RwLock<Instant>,
    /// Indicates whether this session is active.
    active: CancellationToken,
    /// Latest sequence number that was received.
    /// Sequenced packets with sequence numbers less than this one will be discarded.
    last_sequence: AtomicU32,
    /// Collects fragmented packets.
    compound_collector: CompoundCollector,
    order_channels: [OrderChannel; ORDER_CHANNEL_COUNT],
    /// Keeps track of all packets that are waiting to be sent.
    send_queue: SendQueue,
    /// Keeps track of all unprocessed received packets.
    receive_queue: AsyncDeque<BytesMut>,
}

impl Session {
    /// Creates a new session.
    pub fn new(address: SocketAddr, client_guid: i64) -> Arc<Self> {
        let session = Arc::new(Self {
            address,
            guid: client_guid,
            last_update: RwLock::new(Instant::now()),
            active: CancellationToken::new(),
            last_sequence: AtomicU32::new(0),
            compound_collector: CompoundCollector::new(),
            order_channels: Default::default(),
            send_queue: SendQueue::new(),
            receive_queue: AsyncDeque::new(5),
        });

        // Session ticker
        {
            let session = session.clone();
            tokio::spawn(async move {
                let mut interval = tokio::time::interval(INTERNAL_TICK_INTERVAL);
                while !session.active.is_cancelled() {
                    match session.tick().await {
                        Ok(_) => (),
                        Err(e) => tracing::error!("{e}"),
                    }
                    interval.tick().await;
                }
            });
        }

        // Packet processor
        {
            let session = session.clone();
            tokio::spawn(async move {
                let mut interval = tokio::time::interval(TICK_INTERVAL);
                while !session.active.is_cancelled() {
                    match session.process_raw_packet().await {
                        Ok(_) => (),
                        Err(e) => tracing::error!("{e}"),
                    }
                    interval.tick().await;
                }
            });
        }

        tracing::info!("Session {client_guid:X} created");
        session
    }

    /// Processes the raw packet coming directly from the network.
    ///
    /// If a packet is an ACK or NACK type, it will be responded to accordingly (using [`Session::process_ack`] and [`Session::process_nack`]).
    /// Frame batches are processed by [`Session::process_frame_batch`].
    async fn process_raw_packet(&self) -> VexResult<()> {
        let task = tokio::select! {
            _ = self.active.cancelled() => {
                return Ok(())
            },
            task = self.receive_queue.pop() => task
        };
        *self.last_update.write() = Instant::now();

        match *task.first().unwrap() {
            Ack::ID => self.process_ack(task).await,
            Nack::ID => self.process_nack(task).await,
            _ => self.process_frame_batch(task).await,
        }
    }

    /// Processes a batch of frames.
    ///
    /// This performs the actions required by the Raknet reliability layer, such as
    /// * Inserting packets into the order channels
    /// * Inserting packets into the compound collector
    /// * Discarding old sequenced frames
    /// * Acknowledging reliable packets
    async fn process_frame_batch(&self, task: BytesMut) -> VexResult<()> {
        let frame_set = FrameBatch::decode(task)?;
        self.last_sequence
            .store(frame_set.sequence_number, Ordering::SeqCst);

        for frame in frame_set.frames {
            if frame.reliability.is_sequenced()
                && frame.sequence_index < self.last_sequence.load(Ordering::SeqCst)
            {
                // Discard packet
                continue;
            }

            if frame.reliability.is_reliable() {
                // Send ACK
                let encoded = Ack {
                    records: vec![AckRecord::Single(frame.reliable_index)],
                }
                    .encode();

                let acknowledgement = match encoded {
                    Ok(a) => a,
                    Err(e) => {
                        tracing::error!("{e}");
                        continue;
                    }
                };

                self.send_queue
                    .insert(SendPriority::Medium, acknowledgement);
            }

            // TODO: Handle errors in processing properly

            // Sequenced implies ordered
            if frame.reliability.is_ordered() || frame.reliability.is_sequenced() {
                assert_ne!(frame.is_compound, true); // TODO: Figure this out

                // Add packet to order queue
                if let Some(ready) = self.order_channels[frame.order_channel as usize].insert(frame) {
                    for packet in ready {
                        self.process_game_packet(packet.body).await?;
                    }
                }

                continue
            }

            if frame.is_compound {
                if let Some(p) = self.compound_collector.insert(frame) {
                    self.process_game_packet(p).await?
                }
            }
        }

        Ok(())
    }

    /// Processes an unencapsulated game packet.
    async fn process_game_packet(&self, mut task: BytesMut) -> VexResult<()> {
        tracing::info!("Received game packet: {task:?}");

        let packet_id = task.get_u8();
        match packet_id {
            RaknetDisconnect::ID => {
                tracing::debug!("Session {:X} requested disconnect", self.guid);
                self.flag_for_close();
            },
            _ => todo!("Other game packet IDs")
        }

        Ok(())
    }

    /// Processes an acknowledgement received from the client.
    ///
    /// This function unregisters the specified packet IDs from the recovery queue.
    async fn process_ack(&self, task: BytesMut) -> VexResult<()> {
        todo!("Handle ack");
    }

    /// Processes a negative acknowledgement received from the client.
    ///
    /// This function makes sure the packet is retrieved from the recovery queue and sent to the
    /// client again.
    async fn process_nack(&self, task: BytesMut) -> VexResult<()> {
        todo!("Handle nack");
    }

    /// Performs tasks not related to packet processing
    async fn tick(self: &Arc<Self>) -> VexResult<()> {
        // Session has timed out
        if Instant::now().duration_since(*self.last_update.read()) > SESSION_TIMEOUT {
            self.flag_for_close();
            tracing::info!("Session timed out");
        }

        Ok(())
    }

    pub fn flag_for_close(&self) {
        self.active.cancel();
    }

    /// Returns whether the session is currently active.
    ///
    /// If this returns false, any remaining associated processes should be stopped as soon as possible.
    #[inline]
    pub fn active(&self) -> bool {
        !self.active.is_cancelled()
    }

    /// Called by the [`SessionTracker`] to forward packets from the network service to
    /// the session corresponding to the client.
    fn forward(self: &Arc<Self>, buffer: BytesMut) {
        self.receive_queue.push(buffer);
    }
}

/// Keeps track of all sessions on the server.
pub struct SessionTracker {
    /// Whether the server is running.
    /// Once this token is cancelled, the tracker will cancel all the sessions' invidiual tokens.
    global_token: CancellationToken,
    /// Map of all tracked sessions, listed by IP address.
    session_list: DashMap<SocketAddr, Arc<Session>>,
    /// Maximum amount of sessions that this tracker will accept.
    max_session_count: usize,
}

impl SessionTracker {
    /// Creates a new session tracker.
    pub fn new(
        global_token: CancellationToken,
        max_session_count: usize,
    ) -> VexResult<SessionTracker> {
        Ok(SessionTracker {
            global_token,
            session_list: DashMap::new(),
            max_session_count,
        })
    }

    /// Creates a new session and adds it to the tracker.
    pub fn add_session(&self, address: SocketAddr, client_guid: i64) {
        let session = Session::new(address, client_guid);
        self.session_list.insert(address, session);
    }

    /// Forwards a packet from the network service to the correct session.
    pub fn forward_packet(&self, packet: RawPacket) -> VexResult<()> {
        self.session_list
            .get(&packet.address)
            .map(|r| {
                let session = r.value();
                session.forward(packet.buffer);
            })
            .ok_or(vex_error!(
                InvalidRequest,
                "Attempted to forward packet for non-existent session"
            ))
    }

    /// Returns how many clients are currently connected this tracker.
    pub fn session_count(&self) -> usize {
        self.session_list.len()
    }

    /// Returns the maximum amount of sessions this tracker will allow.
    pub fn max_session_count(&self) -> usize {
        self.max_session_count
    }
}
