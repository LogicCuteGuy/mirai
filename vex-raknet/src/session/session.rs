use std::net::SocketAddr;
use std::sync::Arc;
use std::sync::atomic::{AtomicU32, AtomicU64, Ordering};
use std::time::{Duration, Instant};

use bytes::BytesMut;
use parking_lot::{Mutex, RwLock};
use tokio::net::UdpSocket;
use tokio_util::sync::CancellationToken;

use vex_common::VResult;

use crate::async_queue::AsyncDeque;
use crate::session::{CompoundCollector, OrderChannel, RecoveryQueue, SendQueue};

/// Tick interval of the internal session ticker.
const INTERNAL_TICK_INTERVAL: Duration = Duration::from_millis(1000 / 20);
/// Tick interval for session packet processing.
const TICK_INTERVAL: Duration = Duration::from_millis(1000 / 20);
/// Inactivity timeout.
///
/// Any sessions that do not respond within this specified timeout will be disconnect from the server.
/// Timeouts can happen if a client's game crashed for example.
/// They will stop responding to the server, but will not explicitly send a disconnect request.
/// Hence, they have to be disconnected manually after the timeout passes.
const SESSION_TIMEOUT: Duration = Duration::from_secs(5);

const ORDER_CHANNEL_COUNT: usize = 5;

#[derive(Debug)]
pub struct Session<'t> {
    pub token: CancellationToken,
    /// IPv4 socket of the server.
    pub ipv4_socket: Arc<UdpSocket>,
    /// IP address of this session.
    pub address: SocketAddr,
    /// Maximum packet size
    pub mtu: u16,
    /// Client-provided GUID.
    /// These IDs are randomly generated by Minecraft for each connection and are unreliable.
    /// They should not be used as unique identifiers, use the XUID instead.
    pub guid: u64,
    /// Timestamp of when the last packet was received from this client.
    pub last_update: RwLock<Instant>,
    /// Batch number last assigned by the server.
    pub batch_number: AtomicU32,
    /// Sequence index last assigned by the server.
    pub sequence_index: AtomicU32,
    /// Acknowledgment index last used by the server.
    pub acknowledgment_index: AtomicU32,
    /// Latest sequence index that was received.
    /// Sequenced packets with sequence numbers less than this one will be discarded.
    pub client_batch_number: AtomicU32,
    /// Collects fragmented packets.
    pub compound_collector: CompoundCollector,
    /// Channels used to order packets.
    pub order_channels: [OrderChannel; ORDER_CHANNEL_COUNT],
    /// Keeps track of all packets that are waiting to be sent.
    pub send_queue: SendQueue,
    /// Packets that have been received and need to be acknowledged.
    pub confirmed_packets: Mutex<Vec<u32>>,
    /// Keeps track of all unprocessed received packets.
    pub receive_queue: AsyncDeque<BytesMut>,
    /// Queue that stores packets in case they need to be recovered due to packet loss.
    pub recovery_queue: RecoveryQueue,
    /// Current tick of this session, this is increased by one every time the session
    /// processes packets.
    pub current_tick: AtomicU64,
    message_callback: Arc<dyn Fn(&Self, BytesMut) -> VResult<()> + Send + Sync + 't>
}

impl<'t> Session<'t> {
    pub fn new(
        ipv4_socket: Arc<UdpSocket>,
        address: SocketAddr,
        mtu: u16,
        guid: u64,
        callback: Arc<dyn Fn(&Self, BytesMut) -> VResult<()> + Send + Sync + 't>,
    ) -> Arc<Self> {
        let session = Arc::new(Self {
            token: CancellationToken::new(),
            ipv4_socket,
            address,
            mtu,
            guid,
            last_update: RwLock::new(Instant::now()),
            batch_number: AtomicU32::new(0),
            sequence_index: AtomicU32::new(0),
            acknowledgment_index: AtomicU32::new(0),
            client_batch_number: AtomicU32::new(0),
            compound_collector: CompoundCollector::new(),
            order_channels: Default::default(),
            send_queue: SendQueue::new(),
            confirmed_packets: Default::default(),
            receive_queue: AsyncDeque::new(5),
            recovery_queue: RecoveryQueue::new(),
            current_tick: AtomicU64::new(0),
            message_callback: callback
        });

        // Start ticker
        {
            let session = session.clone();
            tokio::spawn(async move {
                let mut interval = tokio::time::interval(INTERNAL_TICK_INTERVAL);
                while !session.token.is_cancelled() {
                    match session.tick().await {
                        Ok(_) => (),
                        Err(e) => tracing::error!("{e}"),
                    }
                    interval.tick().await;
                }

                // Flush last acknowledgements before closing
                match session.flush_acknowledgements().await {
                    Ok(_) => (),
                    Err(e) => {
                        tracing::error!(
                            "Failed to flush last acknowledgements before session close"
                        );
                    }
                }

                // Flush last packets before closing
                match session.flush().await {
                    Ok(_) => (),
                    Err(e) => {
                        tracing::error!("Failed to flush last packets before session close");
                    }
                }
            });
        }

        // Start processor
        {
            let session = session.clone();
            tokio::spawn(async move {
                let mut interval = tokio::time::interval(TICK_INTERVAL);
                while !session.token.is_cancelled() {
                    match session.handle_raw_packet().await {
                        Ok(_) => (),
                        Err(e) => tracing::error!("{e}"),
                    }
                    interval.tick().await;
                }
            });
        }

        session
    }

    pub fn is_active(&self) -> bool {
        !self.token.is_cancelled()
    }

    /// Returns the randomly generated GUID given by the client itself.
    pub const fn get_guid(&self) -> u64 {
        self.guid
    }

    /// Signals to the session that it needs to close.
    pub fn flag_for_close(&self) {
        self.token.cancel();
    }

    /// Performs tasks not related to packet processing
    async fn tick(self: &Arc<Self>) -> VResult<()> {
        let current_tick = self.current_tick.fetch_add(1, Ordering::SeqCst);

        // Session has timed out
        if Instant::now().duration_since(*self.last_update.read()) > SESSION_TIMEOUT {
            self.flag_for_close();
        }

        self.flush().await?;
        Ok(())
    }

    /// Called by the [`SessionTracker`](super::tracker::SessionTracker) to forward packets from the network service to
    /// the session corresponding to the client.
    pub fn on_packet_received(self: &Arc<Self>, buffer: BytesMut) {
        self.receive_queue.push(buffer);
    }
}